#!/usr/bin/env python3
"""
Kickstart Script: Create a new Streamlit project using Triadic backend

Usage:
    python kickstart_streamlit_project.py <project_name> [target_directory]

Example:
    python kickstart_streamlit_project.py my_chatbot ~/projects/
"""

import os
import shutil
import sys
from pathlib import Path

# Files to copy from Triadic project
BACKEND_FILES = [
    "ai_api.py",
    "config.py",
    "exceptions.py",
    "stt.py",
    "tts.py",
    "system.txt",
]

CORE_DIRS = [
    "core",
    "services",
]

UTILS_FILES = [
    "utils/logging_config.py",
    "utils/validators.py",
]

# Template files to generate
TEMPLATES = {
    "app.py": """# app.py
# Streamlit Chat Application - Generated by Triadic Kickstart

import streamlit as st
from backend.ai_api import call_model, stream_model
from backend.core.conversation import ConversationState
from backend.core.message_builder import build_prompt_from_messages
from backend.config import get_openai_api_key

# Page config
st.set_page_config(
    page_title="Chat App",
    page_icon=":material/chat:",
    layout="wide"
)

# Initialize session state
if "conversation" not in st.session_state:
    st.session_state.conversation = ConversationState()
    st.session_state.conversation.add_message(
        "host",
        "Welcome! Start a conversation below."
    )

# Check API key
api_key = get_openai_api_key()
if not api_key:
    st.error("‚ö†Ô∏è OpenAI API key not found. Please set OPENAI_API_KEY environment variable.")
    st.stop()

# Main UI
st.title("üí¨ Chat Application")

# Display conversation
for msg in st.session_state.conversation.messages:
    speaker = msg.get("speaker", "host")
    content = msg.get("content", "")
    
    if speaker == "host":
        st.info(f"**{speaker.title()}**: {content}")
    else:
        with st.chat_message(speaker):
            st.write(content)

# Chat input
if prompt := st.chat_input("Type your message..."):
    # Add user message
    st.session_state.conversation.add_message("user", prompt)
    
    # Show user message
    with st.chat_message("user"):
        st.write(prompt)
    
    # Get AI response
    with st.chat_message("assistant"):
        with st.spinner("Thinking..."):
            # Build prompt
            next_speaker = st.session_state.conversation.next_speaker
            prompt_text = build_prompt_from_messages(
                next_speaker="assistant",
                messages=st.session_state.conversation.get_history(format="streamlit")
            )
            
            # Stream response
            response = stream_model(prompt_text)
            st.write(response)
    
    # Add AI response
    st.session_state.conversation.add_message("assistant", response)
    st.rerun()
""",
    
    "requirements.txt": """streamlit>=1.28.0
openai>=1.0.0
python-dotenv>=1.0.0
""",
    
    ".env.example": """# OpenAI API Key
OPENAI_API_KEY=sk-your-key-here

# Optional: Default Model
OPENAI_MODEL=gpt-5-mini
""",
    
    ".gitignore": """# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/
build/
dist/
*.egg-info/

# Streamlit
.streamlit/secrets.toml

# Environment
.env

# IDE
.vscode/
.idea/
*.swp
*.swo

# OS
.DS_Store
Thumbs.db
""",
    
    "README.md": """# {project_name}

Streamlit chat application powered by Triadic backend.

## Setup

1. **Install dependencies:**
   ```bash
   pip install -r requirements.txt
   ```

2. **Set up environment:**
   ```bash
   cp .env.example .env
   # Edit .env and add your OPENAI_API_KEY
   ```

3. **Run the app:**
   ```bash
   streamlit run app.py
   ```

## Configuration

Edit `backend/config.py` to customize:
- Default model
- Reasoning effort
- Speaker profiles
- System prompt (edit `system.txt`)

## Project Structure

```
{project_name}/
‚îú‚îÄ‚îÄ app.py              # Main Streamlit app
‚îú‚îÄ‚îÄ backend/            # Core backend (from Triadic)
‚îÇ   ‚îú‚îÄ‚îÄ ai_api.py
‚îÇ   ‚îú‚îÄ‚îÄ config.py
‚îÇ   ‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îî‚îÄ‚îÄ services/
‚îú‚îÄ‚îÄ requirements.txt
‚îî‚îÄ‚îÄ .env                # Your API keys (not in git)
```

## Features

- üí¨ Chat interface
- üîÑ Conversation history
- üéØ Framework-agnostic backend
- üîå Easy to extend

## Customization

### Change System Prompt

Edit `system.txt`:
```
You are a helpful assistant. Be concise and friendly.
```

### Add Features

See `AI_BACKEND_REUSE_GUIDE.md` for advanced usage examples.

## License

Same as Triadic project.
""",
    
    ".streamlit/config.toml": """[theme]
primaryColor = "#3b82f6"
backgroundColor = "#ffffff"
secondaryBackgroundColor = "#f0f2f6"
textColor = "#262730"
font = "sans serif"
""",
}


def create_project(project_name: str, target_dir: Path = None) -> Path:
    """
    Create a new Streamlit project with Triadic backend.
    
    Args:
        project_name: Name of the project
        target_dir: Target directory (defaults to current directory)
    
    Returns:
        Path to created project
    """
    if target_dir is None:
        target_dir = Path.cwd()
    
    project_path = target_dir / project_name
    
    # Check if project already exists
    if project_path.exists():
        print(f"‚ùå Error: Directory '{project_path}' already exists!")
        sys.exit(1)
    
    print(f"üöÄ Creating project '{project_name}' in {target_dir}...")
    
    # Create directory structure
    project_path.mkdir(parents=True, exist_ok=True)
    (project_path / "backend").mkdir(exist_ok=True)
    (project_path / "backend" / "core").mkdir(exist_ok=True)
    (project_path / "backend" / "services").mkdir(exist_ok=True)
    (project_path / "utils").mkdir(exist_ok=True)
    (project_path / ".streamlit").mkdir(exist_ok=True)
    
    # Get source paths (assume script is in Triadic root)
    script_dir = Path(__file__).parent
    triadic_root = script_dir
    
    print("üì¶ Copying backend files...")
    
    # Copy backend files
    for file in BACKEND_FILES:
        src = triadic_root / file
        dst = project_path / "backend" / file
        if src.exists():
            shutil.copy2(src, dst)
            print(f"  ‚úì {file}")
        else:
            print(f"  ‚ö†Ô∏è  {file} not found (skipping)")
    
    # Copy core directories
    for dir_name in CORE_DIRS:
        src = triadic_root / dir_name
        dst = project_path / "backend" / dir_name
        if src.exists():
            shutil.copytree(src, dst, dirs_exist_ok=True)
            print(f"  ‚úì {dir_name}/")
        else:
            print(f"  ‚ö†Ô∏è  {dir_name}/ not found (skipping)")
    
    # Copy utils files
    for file in UTILS_FILES:
        src = triadic_root / file
        dst = project_path / file
        if src.exists():
            dst.parent.mkdir(parents=True, exist_ok=True)
            shutil.copy2(src, dst)
            print(f"  ‚úì {file}")
        else:
            print(f"  ‚ö†Ô∏è  {file} not found (skipping)")
    
    print("üìù Creating template files...")
    
    # Create template files
    for filename, content in TEMPLATES.items():
        file_path = project_path / filename
        file_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Replace placeholders
        content = content.replace("{project_name}", project_name)
        
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(content)
        print(f"  ‚úì {filename}")
    
    # Fix imports in backend files
    print("üîß Fixing imports...")
    fix_imports(project_path)
    
    # Create __init__.py files
    print("üìÑ Creating __init__.py files...")
    init_files = [
        project_path / "backend" / "__init__.py",
        project_path / "backend" / "core" / "__init__.py",
        project_path / "backend" / "services" / "__init__.py",
        project_path / "utils" / "__init__.py",
    ]
    for init_file in init_files:
        if not init_file.exists():
            init_file.write_text("# Package marker\n")
            print(f"  ‚úì {init_file.relative_to(project_path)}")
    
    print(f"\n‚úÖ Project created successfully!")
    print(f"\nüìÅ Location: {project_path}")
    print(f"\nüöÄ Next steps:")
    print(f"   1. cd {project_path}")
    print(f"   2. pip install -r requirements.txt")
    print(f"   3. cp .env.example .env")
    print(f"   4. Edit .env and add your OPENAI_API_KEY")
    print(f"   5. streamlit run app.py")
    
    return project_path


def fix_imports(project_path: Path):
    """Fix imports in backend files to use relative imports."""
    backend_path = project_path / "backend"
    
    # Files to fix
    files_to_fix = [
        "ai_api.py",
        "config.py",
    ]
    
    for file in files_to_fix:
        file_path = backend_path / file
        if not file_path.exists():
            continue
        
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()
        
        # Replace absolute imports with relative
        replacements = [
            ("from config import", "from backend.config import"),
            ("from exceptions import", "from backend.exceptions import"),
            ("from utils.logging_config import", "from utils.logging_config import"),
            ("from utils.validators import", "from utils.validators import"),
            ("from core.", "from backend.core."),
            ("from services.", "from backend.services."),
        ]
        
        modified = False
        for old, new in replacements:
            if old in content and not content.startswith("#"):
                content = content.replace(old, new)
                modified = True
        
        if modified:
            with open(file_path, "w", encoding="utf-8") as f:
                f.write(content)
            print(f"  ‚úì Fixed imports in {file}")


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print(__doc__)
        sys.exit(1)
    
    project_name = sys.argv[1]
    target_dir = Path(sys.argv[2]) if len(sys.argv) > 2 else None
    
    try:
        create_project(project_name, target_dir)
    except KeyboardInterrupt:
        print("\n\n‚ùå Cancelled by user")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":
    main()

